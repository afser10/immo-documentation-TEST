import { ModelTransformer, } from "../transformer.js";
import { ModelError } from "../error.js";
export class ScalarBaseTransformer extends ModelTransformer {
    // all scalar field definitions proxy from the same value property in Create
    toConnectSingleFieldDefinition(modelField) {
        // ex -> title: String! @proxy(from: "title.value") # for a non null field in Create
        // or -> title: String # a nullable field in Connect
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `value`,
        });
    }
    // all scalar field definitions proxy from the same value property in Connect
    toConnectListFieldDefinition(modelField) {
        // ex -> titles: [String]! @proxy(from: "title.items.value") # for a non null field in Create
        // or -> titles: [String] # a nullable field in Connect
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `items.value`,
        });
    }
    toConnectDefinition() {
        // all scalar types are built in to Connect already
        return null;
    }
    toCreateDefinition() {
        // all scalar types are built in to Create already
        return null;
    }
    toConnectSingleFieldValue(input) {
        // all scalar types are stored as-is in Connect
        return input;
    }
    toConnectListFieldValue(input) {
        // all scalar types are stored as-is in Connect
        return input;
    }
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            throw new ModelError(`Insertion failed validation\n  -> for model "${this.definition.getTypeName()}"\n  -> on required list field "${field.fieldName}" ${`  -> at input path ${treeContext.path.join(`.`)}.${field.fieldName} <- this field\n  -> required field type "${field.fieldTypeName}${field.list ? `[]` : ``}"\n  -> provided field value:\n    -> ${field.fieldName} is "${JSON.stringify(input, null, 2)}"`.substring(0, 250) + `\n...`}`);
        }
        return input.map((item) => this.parseVisitedInputSingle(item, field, treeContext));
    }
}
//# sourceMappingURL=scalar.js.map