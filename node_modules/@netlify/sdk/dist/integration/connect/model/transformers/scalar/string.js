import { ModelError } from "../../error.js";
import { omitByUndefined } from "../../../utils/omit-by-undefined.js";
import { ScalarBaseTransformer } from "../scalar.js";
export class StringTransformer extends ScalarBaseTransformer {
    // use Editor.Field here so string-like types can extend this class with a more specific type
    toCreateSingleFieldDefinition(modelField) {
        return omitByUndefined({
            ...this.modelFieldToSharedCreateProperties(modelField),
            type: "string",
        });
    }
    toCreateListFieldDefinition(modelField) {
        return omitByUndefined({
            ...this.modelFieldToSharedCreateProperties(modelField),
            type: "list",
            items: {
                type: "string",
            },
        });
    }
    parseVisitedInputSingle(input, field, treeContext) {
        const isString = typeof input === `string`;
        if (!input && !field.required && !isString) {
            return null;
        }
        const fieldIsNullOrUndefined = typeof input === `undefined` && input !== null;
        if (field.required && fieldIsNullOrUndefined) {
            throw new ModelError(`Insertion failed validation\n  -> for model "${this.definition.getTypeName()}"\n  -> on required field "${field.fieldName}" ${`  -> at input path ${treeContext.path.join(`.`)}.${field.fieldName} <- this field\n  -> required field type "${field.fieldTypeName}${field.list ? `[]` : ``}"\n  -> provided field value:\n    -> ${field.fieldName} is "${JSON.stringify(input, null, 2)}"`.substring(0, 250) + `\n...`}`);
        }
        // TODO: we were allowing numbers as strings before the ModelTransformer refactor.
        // This is for backwards compat. Remove this in a breaking change
        const isNumber = typeof input === `number`;
        if (!isString && !isNumber) {
            throw new ModelError(`Input data for field ${field.fieldName} is not a string but should be. Received ${typeof input}.\n\n${JSON.stringify(input, null, 2)}`);
        }
        return isNumber ? String(input) : input;
    }
    toCreateSingleFieldValue(input) {
        return {
            type: "string",
            value: input,
        };
    }
    toCreateSingleFieldValueLocalized(input, _field, treeContext) {
        return {
            type: "string",
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                return {
                    locale,
                    value,
                };
            }, treeContext),
        };
    }
    toCreateListFieldValue(input) {
        return {
            type: `list`,
            items: input?.map?.((listFieldValue) => {
                return {
                    type: "string",
                    value: listFieldValue,
                };
            }),
        };
    }
}
//# sourceMappingURL=string.js.map