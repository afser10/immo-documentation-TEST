import { builtInScalars, } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelWalker {
    model;
    getModelByName;
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.model = model;
        this.getModelByName = getModelByName;
    }
    build() {
        if (this.model.isUnionType && this.model.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.model.compositeTypes) {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel && !builtInScalars.has(typeName)) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.model.getTypeName()}"`);
                }
                if (typeModel) {
                    for (const { name } of typeModel.getFields()) {
                        this.allowedFieldNames.add(name);
                    }
                }
            }
        }
        for (const fieldDefinition of this.model.getFields()) {
            const fieldName = fieldDefinition.name;
            const fieldTypeName = this.model.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInScalars.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.model.getTypeName()}"`);
            }
            const unCameled = this.model.camelToOriginalNames.get(fieldName);
            if (unCameled) {
                this.allowedFieldNames.add(unCameled);
            }
            this.allowedFieldNames.add(fieldName);
        }
    }
    fieldInfoByName(name, visitorState) {
        const definedField = this.model.fieldsMap.get(name);
        if (!definedField) {
            throw new Error(`No defined field found for ${name}`);
        }
        const field = this.makeCoersionField(definedField);
        const model = this.model;
        return {
            name: field.fieldName,
            get originalName() {
                return (model.camelToOriginalNames.get(field.fieldName) || field.fieldName);
            },
            typeName: field.fieldTypeName,
            list: field.list,
            required: field.required,
            is: {
                scalar: builtInScalars.has(field.fieldTypeName) || false,
                node: field?.model?.isNodeType || false,
                union: field?.model?.isUnionType || false,
                object: field?.model?.isObjectType || false,
            },
            get fields() {
                return field.model?.ModelWalker?.fields;
            },
            get visitorContext() {
                return visitorState.context;
            },
            setVisitorContext(newValue) {
                visitorState.context = newValue;
            },
        };
    }
    get fields() {
        const fields = {};
        const modelFields = this.model.getFields();
        if (!modelFields.length)
            return undefined;
        for (const field of modelFields) {
            // ID field is on all node types, don't send it to visitor field info as it's not a user-defined field
            if (field.name === `id` && this.model.isNodeType)
                continue;
            fields[field.name] = this.fieldInfoByName(field.name, {
                context: null,
            });
        }
        return fields;
    }
    visitInputValue(
    // input value can be "any" because the connector author can input any data they want and use the visitor to structure it in the shape defined by their models
    inputValue, visitorState) {
        if (typeof this.model.visitor !== `function`) {
            return inputValue;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const walker = this;
        const visitorInfo = {
            setVisitorContext(newContext) {
                visitorState.context = newContext;
            },
            get fields() {
                return walker.fields;
            },
            get visitorContext() {
                return visitorState?.context;
            },
        };
        return this.model.visitor(inputValue, visitorInfo);
    }
    transformModelValue({ modelValue, coersionField, treeContext, }) {
        const transformer = this.model.ModelTransformer;
        if (!transformer) {
            throw new Error(`ModelTransformer not found for model ${this.model.getTypeName()} on field ${coersionField.fieldName}`);
        }
        const value = transformer.toOutputValue(modelValue, coersionField, treeContext); // TODO: this is temporary to satisfy coerceModelValue
        return value;
    }
    coerceModelValue(modelValue, coersionField, path = [], visitorState = { context: null }) {
        const model = coersionField.model.isUnionType
            ? this.model
            : coersionField.model;
        const asWalker = model.ModelWalker;
        return asWalker.transformModelValue({
            modelValue,
            coersionField,
            treeContext: {
                path,
                visitorState,
            },
        });
    }
    makeCoersionField(field) {
        const fieldTypeName = this.model.getDefinedTypeName(field.type);
        return {
            fieldName: field.name,
            fieldTypeName,
            model: this.model.parseNameToModel(fieldTypeName),
            kind: field.kind,
            list: field.list || false,
            required: field.required || false,
            visitor: field.visitor,
            isRootValue: false,
            localized: field.localized,
        };
    }
    coerceFields(coercedValue, path, visitorState) {
        for (const definedField of this.model.getFields()) {
            const field = this.makeCoersionField(definedField);
            const uncameled = this.model.camelToOriginalNames.get(field.fieldName);
            if (uncameled && typeof coercedValue[uncameled] !== `undefined`) {
                coercedValue[field.fieldName] = coercedValue[uncameled];
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete coercedValue[uncameled];
            }
            coercedValue[field.fieldName] = this.coerceField(field, coercedValue[field.fieldName], path, visitorState);
        }
    }
    coerceField(field, modelFieldValue, path, visitorState) {
        if (field.visitor) {
            modelFieldValue = field.visitor(modelFieldValue, this.fieldInfoByName(field.fieldName, visitorState));
        }
        return field.model.ModelWalker.transformModelValue({
            coersionField: field,
            modelValue: modelFieldValue,
            treeContext: {
                path: field.list ? path : [...path, field.fieldName],
                visitorState,
            },
        });
    }
}
//# sourceMappingURL=walker.js.map