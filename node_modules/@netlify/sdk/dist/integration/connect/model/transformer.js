import { omitByUndefined } from "../utils/omit-by-undefined.js";
import { localDevWarnOnce } from "./utils.js";
// See https://www.notion.so/netlify/Connector-localization-stage-1-f2d04ba3c13c4b1aacd60dfd37d781d0?pvs=4
export class ModelTransformer {
    builder;
    definition;
    constructor(init) {
        this.definition = init.definition;
        this.builder = init.builder;
    }
    get runtimePlatform() {
        return this.builder.runtimePlatform;
    }
    inputNeedsDefaultLocalization(input) {
        if (typeof input === `undefined` || input === null)
            return true;
        if (Array.isArray(input))
            return true;
        if (typeof input === `object`) {
            // check if the object is localized
            for (const locale of this.definition.ModelBuilder.locales) {
                // atleast one locale code as a property is treated as a user localized field
                if (locale.code in input) {
                    return false;
                }
            }
        }
        return true;
    }
    // To allow connectors to easily enable localization without everything breaking, we allow non-localized values on localized fields and treat them as the default locale. This fn normalizes input data that's not localized into a default localized field shape.
    defaultLocalizeFieldValue(input) {
        if (this.inputNeedsDefaultLocalization(input)) {
            return {
                [this.definition.ModelBuilder.getDefaultLocale()]: input,
            };
        }
        if (typeof input !== `object` || !input) {
            throw new Error(`Expected value ${input} to be an object, but it's not. This is a Netlify SDK bug.`);
        }
        return input;
    }
    toOutputValue(input, coersionField, treeContext) {
        // TODO: VERY BAD
        const { path } = treeContext;
        // TODO: VERY VERY BAD
        const list = path[path.length - 1]?.startsWith(`[`) && !Array.isArray(input)
            ? false
            : coersionField.list;
        switch (list) {
            case true:
            case "required":
                return this.toOutputValueList(input, coersionField, treeContext);
            case false:
                return this.toOutputValueSingle(input, coersionField, treeContext);
        }
    }
    maybeVisitListValue(input, coersionField, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NO: backwards compat. Seems type visitors behave differently for enum vs non-enum list values.
        // enum visitors receive the whole array while all others are visited on each array item.
        if (this.definition.isEnumType) {
            return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
        }
        // OH NO 2: before transformer refactor we weren't running type visitors on relationship fields, only on root node values
        if (this.definition.isNodeType && !coersionField.isRootValue) {
            // backwards compat
            return input;
        }
        return input?.map?.((item) => this.definition.ModelWalker.visitInputValue(item, treeContext.visitorState));
    }
    convertObjectLocaleValues(localized, convertValue, treeContext) {
        const convertedLocales = {};
        for (const locale of Object.keys(localized)) {
            if (this.definition.ModelBuilder.localeCodes.has(locale)) {
                convertedLocales[locale] = convertValue(localized[locale], locale);
            }
            else {
                localDevWarnOnce(`unknown-field-locale`, `While processing localized field ${treeContext.path.join(`.`)}, found field property that is not a known locale. Property: ${locale}, available locale codes: ${Array.from(this.definition.ModelBuilder.localeCodes.keys()).join(`, `)}`);
            }
        }
        return convertedLocales;
    }
    parseVisitedInputListLocalized(maybeLocalized, coersionField, treeContext) {
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue) => this.parseVisitedInputList(objectValue, coersionField, treeContext), treeContext);
    }
    toOutputValueList(input, coersionField, treeContext) {
        const visited = this.maybeVisitListValue(input, coersionField, treeContext);
        if (!visited && coersionField.list !== "required") {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (coersionField.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, coersionField, treeContext);
                    return this.toCreateListFieldValueLocalized(parsed, coersionField, treeContext);
                }
                else {
                    return this.toCreateListFieldValue(this.parseVisitedInputList(visited, coersionField, treeContext), coersionField, treeContext);
                }
            }
            case "netlify-connect": {
                if (coersionField.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, coersionField, treeContext);
                    return this.toConnectListFieldValueLocalized(parsed, coersionField, treeContext);
                }
                else {
                    return this.toConnectListFieldValue(this.parseVisitedInputList(visited, coersionField, treeContext), coersionField, treeContext);
                }
            }
        }
    }
    maybeVisitSingleValue(input, coersionField, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NOE: before models refactor we were only running type visitors for document types when they weren't relationship fields. In other words document/node visitors only run on the top level inserted node/document, not on any fields of that type
        if (this.definition.isNodeType && !coersionField.isRootValue)
            return input;
        return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
    }
    parseVisitedInputSingleLocalized(maybeLocalized, coersionField, treeContext) {
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue) => this.parseVisitedInputSingle(objectValue, coersionField, treeContext), treeContext);
    }
    toOutputValueSingle(input, coersionField, treeContext) {
        const visited = this.maybeVisitSingleValue(input, coersionField, treeContext);
        if (!visited && !coersionField.required) {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (coersionField.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, coersionField, treeContext);
                    return this.toCreateSingleFieldValueLocalized(parsed, coersionField, treeContext);
                }
                else {
                    return this.toCreateSingleFieldValue(this.parseVisitedInputSingle(visited, coersionField, treeContext), coersionField, treeContext);
                }
            }
            case "netlify-connect": {
                if (coersionField.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, coersionField, treeContext);
                    return this.toConnectSingleFieldValueLocalized(parsed, coersionField, treeContext);
                }
                else {
                    return this.toConnectSingleFieldValue(this.parseVisitedInputSingle(visited, coersionField, treeContext), coersionField, treeContext);
                }
            }
        }
    }
    toListFieldValue(input, coersionField, treeContext) {
        if (!input && coersionField.list !== `required`)
            return null;
        switch (this.runtimePlatform) {
            case "netlify-create": {
                return this.toCreateListFieldValue(input, coersionField, treeContext);
            }
            case "netlify-connect": {
                return this.toConnectListFieldValue(input, coersionField, treeContext);
            }
        }
    }
    notImplemented(methodName) {
        return new Error(`ModelTransformer.${methodName}() not implemented for type ${this.definition.getTypeName()} of kind ${this.definition.kind}`);
    }
    removeObjectKeysThatHaveNoFieldWithThatName(visited) {
        // Remove any keys that aren't defined fields
        Object.keys(visited || {}).forEach((key) => {
            const fieldName = this.definition.getFinalFieldName(key, visited?.__typename);
            if (!this.definition.ModelWalker.allowedFieldNames.has(fieldName)) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete visited[key];
            }
        });
        return visited;
    }
    toConnectFieldsDefinitionSDL() {
        const { definition } = this;
        let sdl = ``;
        for (const field of definition.fields) {
            const fieldName = field.name;
            const { type } = field;
            // all internal fields are prefixed with _ the only one needed to be queried is _objectId
            // so that frontend html annotations to support Netlify Create can be added using this field.
            if (field.gql?.hidden === true) {
                continue;
            }
            const fieldTypeName = definition.getDefinedTypeName(type, fieldName);
            const transformer = this.definition.parseNameToTransformer(fieldTypeName);
            const fieldSdl = transformer.toConnectFieldDefinition(this.resolveModelField(field));
            if (!fieldSdl)
                continue;
            sdl += fieldSdl;
            const fieldModel = this.definition.ModelBuilder.models.get(fieldTypeName);
            if (fieldModel) {
                const additionalFieldLabels = this.definition.fieldAuthLabels[fieldName];
                sdl += fieldModel.getAuthorizationDirectiveSDL(additionalFieldLabels);
            }
            else {
                sdl +=
                    this.definition.getAuthorizationDirectiveForScalarFieldSDL(fieldName);
            }
            sdl += "\n";
        }
        return sdl;
    }
    // Handles converting a ModelField into an SDL field representation, with null marks, lists, and proxies, depending on the field definition.
    modelFieldToGraphQLFieldSDL(modelField, opts) {
        const description = modelField?.description
            ? `  """${modelField.description}"""\n`
            : ``;
        const fieldName = modelField.name;
        const listOpen = modelField.list ? `[` : ``;
        const type = opts?.asTypeName ||
            this.definition.prefixedTypeName(this.definition.getDefinedTypeName(modelField.type), modelField);
        const nullMark = modelField.required ? `!` : ``;
        const listClose = modelField.list ? `]` : ``;
        const listNullMark = modelField.list === "required" ? `!` : ``;
        const proxyDirective = this.modelFieldToCreateGraphQLProxy(modelField, opts?.proxyFrom);
        const linkDirective = opts?.linkFrom
            ? ` @link(from: "${fieldName}.${opts.linkFrom}"${this.definition?.isMixedUnion ? ` keepObjects: true` : ``})`
            : ``;
        return `${description}  ${fieldName}: ${listOpen + type + nullMark + listClose + listNullMark + proxyDirective + linkDirective}`;
    }
    modelFieldToCreateGraphQLProxy(modelField, proxyFrom) {
        if (!proxyFrom) {
            return ``;
        }
        return this.proxyFrom(`${modelField.name}.${proxyFrom}`);
    }
    proxyFrom(proxyFrom) {
        if (this.runtimePlatform !== `netlify-create`) {
            return ``;
        }
        return ` @proxy(from: "${proxyFrom}")`;
    }
    modelFieldToSharedCreateProperties(modelField) {
        return omitByUndefined({
            name: modelField.name,
            default: modelField.editor?.initialValue,
            group: modelField.editor?.group,
            readOnly: modelField.editor?.readOnly,
            hidden: modelField.editor?.hidden,
            label: modelField.editor?.label,
            description: modelField.description,
            localized: modelField.localized,
            // any field names starting with _ are internal mandatory fields.
            // they shouldn't be set as required in the Create UI as content admins
            // don't need to set these fields, connector authors do.
            required: modelField.name.startsWith(`_`)
                ? undefined
                : modelField.required,
            controlType: this.modelFieldToSharedControlType(modelField),
        });
    }
    modelFieldToSharedCreateNumberProperties(modelField) {
        const { max, min, step, unit } = modelField.editor?.numberOptions || {};
        return {
            type: "number",
            min,
            max,
            step,
            unit,
        };
    }
    modelFieldToSharedControlType(field) {
        const controlType = field.editor?.controlType;
        // These aren't Netlify Create control types, the SDK uses them to differentiate between an Asset that's a file or an image.
        if (controlType === `file` || controlType === `image`) {
            return undefined;
        }
        return controlType;
    }
    // converts this SDK model into a top level Connect SDL GraphQL type
    toConnectDefinition(_ctx) {
        throw this.notImplemented(`toConnectDefinition`);
    }
    // converts this model into a field definition within another top level SDL type
    toConnectFieldDefinition(modelField) {
        switch (modelField.list) {
            case "required":
            case true:
                return this.toConnectListFieldDefinition(modelField);
            case false:
            default:
                return this.toConnectSingleFieldDefinition(modelField);
        }
    }
    toConnectSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    toConnectListFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    // converts this model into a top level Create model definition
    toCreateDefinition() {
        throw this.notImplemented(`toCreateDefinition`);
    }
    // converts this model into a field definition at any level on another Create model definition or field
    toCreateFieldDefinition(modelField) {
        const resolvedModelField = this.resolveModelField(modelField);
        switch (modelField.list) {
            case "required":
            case true:
                return this.toCreateListFieldDefinition(resolvedModelField);
            case false:
            default:
                return this.toCreateSingleFieldDefinition(resolvedModelField);
        }
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateSingleFieldDefinition`);
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateListFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateListFieldDefinition`);
    }
    // takes in connector user input data and normalizes it for storage in Netlify Create
    toCreateSingleFieldValue(_input, _coersionField, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValue`);
    }
    toCreateSingleFieldValueLocalized(_input, _coersionField, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValueLocalized`);
    }
    // same as above but for when this type is used in a list
    toCreateListFieldValue(_input, _coersionField, _treeContext) {
        throw this.notImplemented(`toCreateListFieldValue`);
    }
    toCreateListFieldValueLocalized(input, field, treeContext) {
        return {
            type: `list`,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                if (!Array.isArray(value)) {
                    throw new Error(`Encountered non-array value where an array was expected. This may be a bug in the Netlify SDK.`);
                }
                return {
                    locale,
                    items: value.map((v) => this.toCreateSingleFieldValue.bind(this)(v, field, treeContext)),
                };
            }, treeContext),
        };
    }
    // same as above but for Netlify Connect data storage
    toConnectSingleFieldValue(_input, _coersionField, _treeContext) {
        throw this.notImplemented(`toConnectSingleFieldValue`);
    }
    toConnectSingleFieldValueLocalized(input, coersionField, treeContext) {
        const formattedLocales = {};
        for (const locale of Object.keys(input)) {
            formattedLocales[locale] = this.toConnectSingleFieldValue(input[locale], coersionField, treeContext);
        }
        return formattedLocales;
    }
    toConnectListFieldValue(_input, _coersionField, _treeContext) {
        throw this.notImplemented(`toConnectListFieldValue`);
    }
    toConnectListFieldValueLocalized(input, coersionField, treeContext) {
        const formattedLocales = {};
        for (const locale of Object.keys(input)) {
            formattedLocales[locale] = this.toConnectListFieldValue(input[locale], coersionField, treeContext);
        }
        return formattedLocales;
    }
    // throws helpful errors when the data that's about to be inserted in the DB is the wrong type
    // "parseVisited" because the connector can insert any shape they want, and then transform it to the right shape with a visitor fn. So we need to validate that it's the right type _after_ they've visited it (if they did visit it - we will still parse here if they didn't. naming?)
    // only runs during local dev so that incorrect data in prod doesn't kill the whole sourcing process. or perhaps we can catch ModelError and only warn in prod, but fail sourcing in dev.
    parseVisitedInputSingle(_visited, _coersionField, _treeContext) {
        throw this.notImplemented(`parseVisitedInputSingle`);
    }
    parseVisitedInputList(_visited, _coersionField, _treeContext) {
        throw this.notImplemented(`parseVisitedInputList`);
    }
    resolveModelField(field) {
        if (typeof field.type === `string`) {
            // don't mutate so the users field definitions aren't modified
            return {
                ...field,
                type: this.definition.getDefinedType(field.type),
            };
        }
        return field;
    }
}
//# sourceMappingURL=transformer.js.map