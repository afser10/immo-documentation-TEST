{"version":3,"file":"add-inferred-fields.js","names":["_isFile","require","_date","_derivedTypes","_reportOnce","_is32BitInteger","groupBy","sortBy","get","upperFirst","ObjectTypeComposer","GraphQLList","invariant","report","getDataStore","addInferredFields","schemaComposer","typeComposer","exampleValue","typeMapping","config","getInferenceConfig","defaults","shouldAddFields","addInferredFieldsImpl","exampleObject","prefix","getTypeName","unsanitizedFieldPath","deprecatedNodeKeys","size","plugin","getExtension","reportOnce","module","exports","fields","Object","keys","forEach","unsanitizedKey","key","createFieldName","push","fieldsByKey","field","possibleFields","selectedField","length","resolveMultipleFields","possibleFieldsNames","map","join","warn","fieldConfig","getFieldConfig","hasField","addFields","setFieldExtension","Set","selector","arrays","value","Array","isArray","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","multiple","add","getSimpleFieldConfig","pop","split","extensions","proxy","from","type","nodeField","find","canonicalField","mapping","path","link","by","foreignKey","replace","linkedTypesSet","linkedValues","linkedNodes","iterateNodes","node","has","internal","id","getNode","linkedTypes","typeName","sort","getOrCreateUTC","utc","setTypes","getOTC","setResolveType","is32BitInteger","isDate","dateformat","isFile","fileByRelativePath","Date","String","fieldTypeComposer","getFieldTC","lists","fieldType","getFieldType","ofType","createTypeName","create","setExtension","addDerivedType","derivedTypeName","inferenceConfig","Error","suffix","slice","NON_ALPHA_NUMERIC_EXPR","RegExp","fieldName","replaced","match","char","index","hasExtension"],"sources":["../../../src/schema/infer/add-inferred-fields.js"],"sourcesContent":["const groupBy = require(`lodash.groupby`);\nconst sortBy = require(`lodash.sortby`);\nconst get = require(`lodash.get`);\nconst { upperFirst } = require(`../../core-utils/upper-first`);\n\nconst { ObjectTypeComposer } = require(`graphql-compose`);\nconst { GraphQLList } = require(`graphql`);\nconst invariant = require(`invariant`);\nconst report = require(`../../reporter`);\n\nimport { isFile } from \"./is-file\";\nimport { isDate } from \"../types/date\";\nimport { addDerivedType } from \"../types/derived-types\";\nimport { reportOnce } from \"../../utils/report-once\";\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\";\nconst { getDataStore } = require(`../../datastore`);\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  typeMapping,\n}) => {\n  const config = getInferenceConfig({\n    typeComposer,\n    defaults: {\n      shouldAddFields: true,\n    },\n  });\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    unsanitizedFieldPath: [typeComposer.getTypeName()],\n    typeMapping,\n    config,\n  });\n\n  if (deprecatedNodeKeys.size > 0) {\n    const plugin = typeComposer.getExtension(`plugin`);\n\n    reportOnce(\n      `Plugin \"${plugin}\" is using the ___NODE convention which is deprecated. This plugin should use the @link directive instead.`,\n      `verbose`,\n    );\n  }\n};\n\nmodule.exports = {\n  addInferredFields,\n};\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  exampleObject,\n  typeMapping,\n  prefix,\n  unsanitizedFieldPath,\n  config,\n}) => {\n  const fields = [];\n  Object.keys(exampleObject).forEach((unsanitizedKey) => {\n    const key = createFieldName(unsanitizedKey);\n    fields.push({\n      key,\n      unsanitizedKey,\n      exampleValue: exampleObject[unsanitizedKey],\n    });\n  });\n\n  const fieldsByKey = groupBy(fields, (field) => field.key);\n\n  Object.keys(fieldsByKey).forEach((key) => {\n    const possibleFields = fieldsByKey[key];\n    let selectedField;\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields);\n      const possibleFieldsNames = possibleFields\n        .map((field) => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `);\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${field.key}\\` - [${possibleFieldsNames}]. Gatsby will use \\`${field.unsanitizedKey}\\`.`,\n      );\n      selectedField = field;\n    } else {\n      selectedField = possibleFields[0];\n    }\n\n    const fieldConfig = getFieldConfig({\n      ...selectedField,\n      schemaComposer,\n      typeComposer,\n      prefix,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n    });\n\n    if (!fieldConfig) return;\n\n    if (!typeComposer.hasField(key)) {\n      if (config.shouldAddFields) {\n        typeComposer.addFields({ [key]: fieldConfig });\n        typeComposer.setFieldExtension(key, `createdFrom`, `inference`);\n      }\n    }\n  });\n\n  return typeComposer;\n};\n\nconst deprecatedNodeKeys = new Set();\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  prefix,\n  exampleValue,\n  key,\n  unsanitizedKey,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n}) => {\n  const selector = `${prefix}.${key}`;\n  unsanitizedFieldPath.push(unsanitizedKey);\n\n  let arrays = 0;\n  let value = exampleValue;\n  while (Array.isArray(value)) {\n    value = value[0];\n    arrays++;\n  }\n\n  let fieldConfig;\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector });\n  } else if (unsanitizedKey.includes(`___NODE`)) {\n    // TODO(v5): Remove ability to use foreign keys like this (e.g. author___NODE___contact___email)\n    // and recommend using schema customization instead\n\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      value: exampleValue,\n      key: unsanitizedKey,\n    });\n    arrays = arrays + (value.multiple ? 1 : 0);\n\n    deprecatedNodeKeys.add(unsanitizedKey);\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      key,\n      value,\n      selector,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n      arrays,\n    });\n  }\n\n  unsanitizedFieldPath.pop();\n  if (!fieldConfig) return null;\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey.split(`___NODE`)[0]) {\n    fieldConfig = {\n      ...fieldConfig,\n      extensions: {\n        ...(fieldConfig.extensions || {}),\n        proxy: { from: unsanitizedKey },\n      },\n    };\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] };\n    arrays--;\n  }\n\n  return fieldConfig;\n};\n\nconst resolveMultipleFields = (possibleFields) => {\n  const nodeField = possibleFields.find((field) =>\n    field.unsanitizedKey.includes(`___NODE`),\n  );\n  if (nodeField) {\n    return nodeField;\n  }\n\n  const canonicalField = possibleFields.find(\n    (field) => field.unsanitizedKey === field.key,\n  );\n  if (canonicalField) {\n    return canonicalField;\n  }\n\n  return sortBy(possibleFields, (field) => field.unsanitizedKey)[0];\n};\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector);\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`);\n  return {\n    type,\n    extensions: {\n      link: { by: path.join(`.`) || `id` },\n    },\n  };\n};\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1];\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`);\n  const linkedTypesSet = new Set();\n\n  if (foreignKey) {\n    const linkedValues = new Set(value.linkedNodes);\n    getDataStore()\n      .iterateNodes()\n      .forEach((node) => {\n        const value = get(node, foreignKey);\n        if (linkedValues.has(value)) {\n          linkedTypesSet.add(node.internal.type);\n        }\n      });\n  } else {\n    value.linkedNodes.forEach((id) => {\n      const node = getDataStore().getNode(id);\n      if (node) {\n        linkedTypesSet.add(node.internal.type);\n      }\n    });\n  }\n\n  const linkedTypes = [...linkedTypesSet];\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value.linkedNodes}\".`,\n  );\n\n  let type;\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`;\n    type = schemaComposer.getOrCreateUTC(typeName, (utc) => {\n      utc.setTypes(\n        linkedTypes.map((typeName) => schemaComposer.getOTC(typeName)),\n      );\n      utc.setResolveType((node) => node.internal.type);\n    });\n  } else {\n    type = linkedTypes[0];\n  }\n\n  return {\n    type,\n    extensions: {\n      link: { by: foreignKey || `id`, from: key },\n    },\n  };\n};\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  key,\n  value,\n  selector,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n  arrays,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` };\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` };\n    case `string`:\n      if (isDate(value)) {\n        return { type: `Date`, extensions: { dateformat: {} } };\n      }\n      if (isFile(unsanitizedFieldPath, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, extensions: { fileByRelativePath: {} } };\n      }\n      return { type: `String` };\n    case `object`:\n      if (value instanceof Date) {\n        return { type: `Date`, extensions: { dateformat: {} } };\n      }\n      if (value instanceof String) {\n        return { type: `String` };\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        let fieldTypeComposer;\n        if (typeComposer.hasField(key)) {\n          fieldTypeComposer = typeComposer.getFieldTC(key);\n          // If we have an object as a field value, but the field type is\n          // explicitly defined as something other than an ObjectType\n          // we can bail early.\n          if (!(fieldTypeComposer instanceof ObjectTypeComposer)) return null;\n          // If the array depth of the field value and of the explicitly\n          // defined field type don't match we can also bail early.\n          let lists = 0;\n          let fieldType = typeComposer.getFieldType(key);\n          while (fieldType.ofType) {\n            if (fieldType instanceof GraphQLList) lists++;\n            fieldType = fieldType.ofType;\n          }\n          if (lists !== arrays) return null;\n        } else {\n          // When the field type has not been explicitly defined, we\n          // don't need to continue in case of @dontInfer\n          if (!config.shouldAddFields) return null;\n\n          const typeName = createTypeName(selector);\n          if (schemaComposer.has(typeName)) {\n            // Type could have been already created via schema customization\n            fieldTypeComposer = schemaComposer.getOTC(typeName);\n          } else {\n            fieldTypeComposer = ObjectTypeComposer.create(\n              typeName,\n              schemaComposer,\n            );\n            fieldTypeComposer.setExtension(`createdFrom`, `inference`);\n            fieldTypeComposer.setExtension(\n              `plugin`,\n              typeComposer.getExtension(`plugin`),\n            );\n            addDerivedType({\n              typeComposer,\n              derivedTypeName: fieldTypeComposer.getTypeName(),\n            });\n          }\n        }\n\n        // Inference config options are either explicitly defined on a type\n        // with directive/extension, or inherited from the parent type.\n        const inferenceConfig = getInferenceConfig({\n          typeComposer: fieldTypeComposer,\n          defaults: config,\n        });\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            unsanitizedFieldPath,\n            config: inferenceConfig,\n          }),\n        };\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`);\n};\n\nconst createTypeName = (selector) => {\n  const keys = selector.split(`.`);\n  const suffix = keys.slice(1).map(upperFirst).join(``);\n  return `${keys[0]}${suffix}`;\n};\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`);\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = (key) => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`,\n  );\n\n  const fieldName = key.split(`___NODE`)[0];\n  const replaced = fieldName.replace(NON_ALPHA_NUMERIC_EXPR, `_`);\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`));\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced;\n  }\n\n  return replaced;\n};\n\nconst getInferenceConfig = ({ typeComposer, defaults }) => {\n  return {\n    shouldAddFields: typeComposer.hasExtension(`infer`)\n      ? typeComposer.getExtension(`infer`)\n      : defaults.shouldAddFields,\n  };\n};\n"],"mappings":"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"}