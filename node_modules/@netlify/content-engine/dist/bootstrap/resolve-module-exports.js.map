{"version":3,"file":"resolve-module-exports.js","names":["_reporter","_interopRequireDefault","require","_testImportError","_resolveJsFilePath","_preferDefault","resolveModuleExports","modulePath","rootDir","process","cwd","moduleFilePath","resolveJSFilepath","filePath","maybeAddFileProtocol","rawImportedModule","importedModule","preferDefault","Object","keys","filter","exportName","error","testImportError","report","panic"],"sources":["../../src/bootstrap/resolve-module-exports.ts"],"sourcesContent":["import report from \"../reporter\";\nimport { testImportError } from \"../utils/test-import-error\";\nimport {\n  maybeAddFileProtocol,\n  resolveJSFilepath,\n} from \"./resolve-js-file-path\";\nimport { preferDefault } from \"./prefer-default\";\n\ninterface IResolveModuleExportsOptions {\n  rootDir?: string;\n}\n\n/**\n * Given a path to a module, return an array of the module's exports.\n *\n * It can run in two modes:\n * 1. `analysis` mode gets exports via static analysis by traversing the file's AST with babel\n * 2. `import` mode gets exports by directly importing the module and accessing its properties\n *\n * At the time of writing, analysis mode is used for files that can be jsx (e.g. gatsby-browser, gatsby-ssr)\n * and import mode is used for files that can be js or mjs.\n *\n * Returns [] for invalid paths and modules without exports.\n */\nexport async function resolveModuleExports(\n  modulePath: string,\n  { rootDir = process.cwd() }: IResolveModuleExportsOptions = {},\n): Promise<Array<string>> {\n  try {\n    const moduleFilePath = await resolveJSFilepath({\n      rootDir,\n      filePath: modulePath,\n    });\n\n    if (!moduleFilePath) {\n      return [];\n    }\n\n    const filePath = maybeAddFileProtocol(moduleFilePath);\n    const rawImportedModule = await import(filePath);\n\n    // If the module is cjs, the properties we care about are nested under a top-level `default` property\n    const importedModule = preferDefault(rawImportedModule);\n\n    return Object.keys(importedModule).filter(\n      (exportName) => exportName !== `__esModule`,\n    );\n  } catch (error) {\n    if (!testImportError(modulePath, error)) {\n      // if module exists, but requiring it cause errors,\n      // show the error to the user and terminate build\n      report.panic(`Error in \"${modulePath}\":`, error);\n    }\n  }\n\n  return [];\n}\n"],"mappings":";;;;;AAAA,IAAAA,SAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,gBAAA,GAAAD,OAAA;AACA,IAAAE,kBAAA,GAAAF,OAAA;AAIA,IAAAG,cAAA,GAAAH,OAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeI,oBAAoBA,CACxCC,UAAkB,EAClB;EAAEC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAAC;AAAgC,CAAC,GAAG,CAAC,CAAC,EACtC;EACxB,IAAI;IACF,MAAMC,cAAc,GAAG,MAAM,IAAAC,oCAAiB,EAAC;MAC7CJ,OAAO;MACPK,QAAQ,EAAEN;IACZ,CAAC,CAAC;IAEF,IAAI,CAACI,cAAc,EAAE;MACnB,OAAO,EAAE;IACX;IAEA,MAAME,QAAQ,GAAG,IAAAC,uCAAoB,EAACH,cAAc,CAAC;IACrD,MAAMI,iBAAiB,GAAG,MAAM,MAAM,CAACF,QAAQ,CAAC;;IAEhD;IACA,MAAMG,cAAc,GAAG,IAAAC,4BAAa,EAACF,iBAAiB,CAAC;IAEvD,OAAOG,MAAM,CAACC,IAAI,CAACH,cAAc,CAAC,CAACI,MAAM,CACtCC,UAAU,IAAKA,UAAU,KAAM,YAClC,CAAC;EACH,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,IAAI,CAAC,IAAAC,gCAAe,EAAChB,UAAU,EAAEe,KAAK,CAAC,EAAE;MACvC;MACA;MACAE,iBAAM,CAACC,KAAK,CAAE,aAAYlB,UAAW,IAAG,EAAEe,KAAK,CAAC;IAClD;EACF;EAEA,OAAO,EAAE;AACX"}