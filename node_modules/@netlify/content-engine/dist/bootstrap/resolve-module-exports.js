"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.resolveModuleExports = resolveModuleExports;
var _reporter = _interopRequireDefault(require("../reporter"));
var _testImportError = require("../utils/test-import-error");
var _resolveJsFilePath = require("./resolve-js-file-path");
var _preferDefault = require("./prefer-default");
/**
 * Given a path to a module, return an array of the module's exports.
 *
 * It can run in two modes:
 * 1. `analysis` mode gets exports via static analysis by traversing the file's AST with babel
 * 2. `import` mode gets exports by directly importing the module and accessing its properties
 *
 * At the time of writing, analysis mode is used for files that can be jsx (e.g. gatsby-browser, gatsby-ssr)
 * and import mode is used for files that can be js or mjs.
 *
 * Returns [] for invalid paths and modules without exports.
 */
async function resolveModuleExports(modulePath, {
  rootDir = process.cwd()
} = {}) {
  try {
    const moduleFilePath = await (0, _resolveJsFilePath.resolveJSFilepath)({
      rootDir,
      filePath: modulePath
    });
    if (!moduleFilePath) {
      return [];
    }
    const filePath = (0, _resolveJsFilePath.maybeAddFileProtocol)(moduleFilePath);
    const rawImportedModule = await import(filePath);

    // If the module is cjs, the properties we care about are nested under a top-level `default` property
    const importedModule = (0, _preferDefault.preferDefault)(rawImportedModule);
    return Object.keys(importedModule).filter(exportName => exportName !== `__esModule`);
  } catch (error) {
    if (!(0, _testImportError.testImportError)(modulePath, error)) {
      // if module exists, but requiring it cause errors,
      // show the error to the user and terminate build
      _reporter.default.panic(`Error in "${modulePath}":`, error);
    }
  }
  return [];
}
//# sourceMappingURL=resolve-module-exports.js.map